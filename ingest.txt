Directory structure:
└── belpavz-ycbot/
    ├── app.db
    ├── app.py
    ├── bot.py
    ├── config.py
    ├── forms.py
    ├── phone_database.json
    ├── requirements.txt
    ├── start_app.sh
    ├── utils.py
    ├── yc.py
    ├── daemon, ngnix/
    │   ├── default
    │   ├── myapp.service
    │   └── ycbot
    ├── static/
    │   └── style.css
    └── tamplates/
        ├── login.html
        ├── profile.html
        └── signup.html

================================================
File: app.py
================================================
# app.py
from flask import Flask, request, render_template, redirect, url_for, session
import config
import utils
import yclients
from flask_sqlalchemy import SQLAlchemy
import os
import bcrypt  # Импортируем bcrypt

app = Flask(__name__)
app.config.from_object('config.Config')
app.secret_key = app.config['SECRET_KEY']
db = SQLAlchemy(app)  # Инициализация SQLAlchemy

# Определение модели данных для связи с Yclients


class UsersYclients(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer)
    salon_id = db.Column(db.Integer)
    user_yclients_id = db.Column(db.Integer)

    def __repr__(self):
        return f'<UsersYclients {self.user_id} {self.salon_id} {self.user_yclients_id}>'

# Определение модели пользователя


class YourUserModel(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100))
    email = db.Column(db.String(100), unique=True)
    phone = db.Column(db.String(20))
    password_hash = db.Column(db.String(128))  # Переименовали поле

    def __repr__(self):
        return f'<User {self.name} {self.email}>'

    def set_password(self, password):
        """Хеширует пароль и сохраняет хеш."""
        self.password_hash = bcrypt.hashpw(password.encode(
            'utf-8'), bcrypt.gensalt()).decode('utf-8')

    def check_password(self, password):
        """Проверяет, соответствует ли пароль хешу."""
        return bcrypt.checkpw(password.encode('utf-8'), self.password_hash.encode('utf-8'))


# Создание базы данных (если ее нет)
with app.app_context():
    db.create_all()


@app.route('/signup', methods=['GET', 'POST'])
def signup():
    salon_id = request.args.get('salon_id')
    user_data_encoded = request.args.get('user_data')
    user_data_sign = request.args.get('user_data_sign')
    salon_ids = request.args.getlist('salon_ids[]')

    if request.method == 'POST':
        password = request.form.get('password')
        email = request.form.get('email')
        name = request.form.get('name')
        phone = request.form.get('phone')

        # Ищем пользователя в базе данных по email
        user = YourUserModel.query.filter_by(email=email).first()
        if user:
            user_id = user.id
        else:
            # Создаем нового пользователя
            new_user = YourUserModel(name=name, email=email, phone=phone)
            new_user.set_password(password)  # Хешируем пароль
            db.session.add(new_user)
            db.session.commit()
            user_id = new_user.id

        # После успешной регистрации перенаправляем на страницу активации
        return redirect(url_for('activate', salon_id=salon_id, user_id=user_id))

    if user_data_encoded and user_data_sign:
        # Передача данных пользователя включена
        user_data = utils.decode_user_data(
            user_data_encoded, app.config['PARTNER_TOKEN'])
        if user_data and utils.verify_signature(user_data_encoded, user_data_sign, app.config['PARTNER_TOKEN']):
            # Подпись валидна, можно использовать данные
            return render_template('signup.html', salon_id=salon_id, user_data=user_data, salon_ids=salon_ids)
        else:
            # Ошибка подписи или декодирования
            return "Invalid signature or data!", 400
    else:
        # Данные пользователя не переданы, отображаем обычную форму
        return render_template('signup.html', salon_id=salon_id, user_data=None, salon_ids=salon_ids)


@app.route('/')
def home():
    return "Ваше приложение работает!"  # или вернуть HTML-шаблон


@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        email = request.form.get('email')
        password = request.form.get('password')

        user = YourUserModel.query.filter_by(email=email).first()
        if user and user.check_password(password):
            # Аутентификация успешна
            session['user_id'] = user.id  # Сохраняем ID пользователя в сессии
            # Перенаправляем на страницу профиля
            return redirect(url_for('profile'))
        else:
            # Неверный email или пароль
            return render_template('login.html', error="Неверный email или пароль")

    return render_template('login.html')


@app.route('/profile')
def profile():
    user_id = session.get('user_id')
    if user_id:
        user = YourUserModel.query.get(user_id)
        return render_template('profile.html', user=user)
    else:
        return redirect(url_for('login'))


@app.route('/activate', methods=['POST'])
def activate():
    salon_id = request.form.get('salon_id')
    salon_ids = request.form.getlist('salon_ids[]')
    user_id = request.form.get('user_id')

    api_key = app.config['API_KEY']
    # Получаем application_id из конфига
    application_id = app.config['APPLICATION_ID']
    # Получаем webhook_url из конфига
    webhook_urls = [app.config['WEBHOOK_URL']]
    # channels = ["sms", "whatsapp"]  # Укажите каналы, если необходимо

    if salon_ids:
        for salon_id_item in salon_ids:
            success, user_yclients_id, response = yclients.activate_integration(
                salon_id_item, api_key)
            if success:
                print(
                    f"Интеграция успешно активирована для филиала {salon_id_item}, USER_ID: {user_yclients_id}")
                # Сохраняем данные в базе данных
                entry = UsersYclients(
                    user_id=user_id, salon_id=salon_id_item, user_yclients_id=user_yclients_id)
                db.session.add(entry)
                db.session.commit()

                # Отправляем настройки интеграции
                success, message = yclients.send_integration_settings(
                    salon_id_item, application_id, api_key, webhook_urls)
                if success:
                    print(
                        f"Настройки интеграции успешно отправлены для филиала {salon_id_item}")
                else:
                    print(
                        f"Ошибка отправки настроек интеграции для филиала {salon_id_item}: {message}")

            else:
                print(
                    f"Ошибка активации для филиала {salon_id_item}: {response}")
                # TODO: Обработать ошибку
    else:
        success, user_yclients_id, response = yclients.activate_integration(
            salon_id, api_key)
        if success:
            print(
                f"Интеграция успешно активирована, USER_ID: {user_yclients_id}")
            # Сохраняем данные в базе данных
            entry = UsersYclients(
                user_id=user_id, salon_id=salon_id, user_yclients_id=user_yclients_id)
            db.session.add(entry)
            db.session.commit()

            # Отправляем настройки интеграции
            success, message = yclients.send_integration_settings(
                salon_id, application_id, api_key, webhook_urls)
            if success:
                print(
                    f"Настройки интеграции успешно отправлены для филиала {salon_id}")
            else:
                print(
                    f"Ошибка отправки настроек интеграции для филиала {salon_id}: {message}")

        else:
            print(f"Ошибка активации: {response}")
            # TODO: Обработать ошибку

    return "Интеграция активирована! (проверьте логи)", 200


@app.route('/logout')
def logout():
    session.pop('user_id', None)
    return redirect(url_for('login'))


# ... остальной код ...
if __name__ == '__main__':
    # app.run(debug=True)  # Включите debug mode для разработки
    # app.run(debug=True, host="0.0.0.0", port=8000)
    pass


================================================
File: bot.py
================================================
import logging
from dotenv import load_dotenv
import os
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, KeyboardButton, ReplyKeyboardMarkup, constants
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    MessageHandler,
    filters,
    ContextTypes,
    CallbackQueryHandler,)

from yclients import YClientsAPI
from datetime import datetime, date
import json

# Настройка логирования
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.WARNING
)
logger = logging.getLogger(__name__)

load_dotenv()

YCLIENTS_API_TOKEN = os.getenv('YCLIENTS_API_TOKEN')
COMPANY_ID = os.getenv('COMPANY_ID')
FORM_ID = os.getenv('FORM_ID')
TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')

if not all([YCLIENTS_API_TOKEN, COMPANY_ID, FORM_ID, TELEGRAM_BOT_TOKEN]):
    logger.critical(
        "Необходимо установить переменные окружения: YCLIENTS_API_TOKEN, YCLIENTS_COMPANY_ID, FORM_ID, TELEGRAM_BOT_TOKEN")
    raise ValueError("Отсутствуют необходимые переменные окружения")

# Инициализация API YCLIENTS
api = YClientsAPI(token=YCLIENTS_API_TOKEN,
                  company_id=COMPANY_ID, form_id=FORM_ID)

# Путь к файлу базы данных телефонов
PHONE_DATABASE = "phone_database.json"

# Загрузка базы данных телефонов из файла


def load_phone_database():
    try:
        with open(PHONE_DATABASE, "r") as f:
            return json.load(f)
    except FileNotFoundError:
        return {}
    except json.JSONDecodeError:
        logger.warning("Файл базы данных телефонов поврежден. Создаю новый.")
        return {}

# Сохранение базы данных телефонов в файл


def save_phone_database(phone_data):
    with open(PHONE_DATABASE, "w") as f:
        json.dump(phone_data, f, indent=4)

# Получение списка сотрудников


def get_staff():
    try:
        staff = api.get_staff()
        if staff and staff['success']:
            return staff['data']
        else:
            logger.error(
                f"Ошибка при получении списка сотрудников: {staff.get('meta', 'No meta data available') if staff else 'No response'}")
            return None
    except Exception as e:
        logger.error(f"Исключение при получении списка сотрудников: {e}")
        return None

# Получение списка услуг


def get_services(staff_id=None):
    try:
        services = api.get_services(staff_id=staff_id)
        if services and services['success']:
            return services['data']['services']
        else:
            logger.error(
                f"Ошибка при получении списка услуг: {services.get('meta', 'No meta data available') if services else 'No response'}")
            return None
    except Exception as e:
        logger.error(f"Исключение при получении списка услуг: {e}")
        return None

# Получение доступных дат для записи


def get_available_days(service_id, staff_id=None):
    try:
        available_days = api.get_available_days(
            staff_id=staff_id, service_id=service_id)
        if available_days and available_days['success']:
            return available_days['data']['booking_dates']
        else:
            logger.error(
                f"Ошибка при получении доступных дат: {available_days.get('meta', 'No meta data available') if available_days else 'No response'}")
            return None
    except Exception as e:
        logger.error(f"Исключение при получении списка доступных дат: {e}")
        return None

# Получение доступного времени для записи


def get_available_times(service_id, staff_id, selected_date):
    try:
        available_times = api.get_available_times(
            staff_id=staff_id, service_id=service_id, day=selected_date)
        if available_times and available_times['success']:
            return available_times['data']
        else:
            logger.error(
                f"Ошибка при получении доступного времени: {available_times.get('meta', 'No meta data available') if available_times else 'No response'}")
            return None
    except Exception as e:
        logger.error(f"Исключение при получении доступного времени: {e}")
        return None


# Функция для перевода месяца на русский
def translate_month_to_russian(month_year):
    month_year_parts = month_year.split()
    month = month_year_parts[0]
    year = month_year_parts[1]
    month_dict = {
        "January": "Январь",
        "February": "Февраль",
        "March": "Март",
        "April": "Апрель",
        "May": "Май",
        "June": "Июнь",
        "July": "Июль",
        "August": "Август",
        "September": "Сентябрь",
        "October": "Октябрь",
        "November": "Ноябрь",
        "December": "Декабрь",
    }
    translated_month = month_dict.get(month)
    return f"{translated_month} {year}" if translated_month else month_year


# Функция для получения дня недели на русском
def get_weekday_russian(date_obj):
    weekday_dict = {
        0: "Пн",
        1: "Вт",
        2: "Ср",
        3: "Чт",
        4: "Пт",
        5: "Сб",
        6: "Вс"
    }
    return weekday_dict[date_obj.weekday()]


# Команда /start
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await update.message.reply_text(
        "Привет! Я бот для онлайн-записи. Используйте /book, чтобы записаться на услугу."
    )

# Команда /book


async def book(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    try:
        await context.bot.delete_message(
            chat_id=update.effective_chat.id,
            message_id=update.message.message_id
        )
    except Exception as e:
        logger.warning(f"Не удалось удалить сообщение '/book': {e}")

    staff_data = get_staff()
    if not staff_data:
        await update.message.reply_text("Не удалось получить список сотрудников. Попробуйте позже.")
        return

    keyboard = [
        [InlineKeyboardButton(staff_member["name"],
                              callback_data=f"staff_{staff_member['id']}")]
        for staff_member in staff_data
    ]
    keyboard.append([InlineKeyboardButton(
        "Любой сотрудник", callback_data="staff_any")])
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text("Выберите сотрудника:", reply_markup=reply_markup)

# Обработка выбора сотрудника


async def choose_staff(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    staff_id = query.data.split("_")[1] if query.data.split("_")[
        1] != 'any' else None
    context.user_data["staff_id"] = staff_id

    services_data = get_services(staff_id)
    if not services_data:
        await query.edit_message_text("Не удалось получить список услуг. Попробуйте позже.")
        return

    keyboard = [
        [InlineKeyboardButton(
            f"{service['title']} - {service.get('price_min', 'Неизвестно')} руб.", callback_data=f"service_{service['id']}")]
        for service in services_data
    ]
    keyboard.append([InlineKeyboardButton(
        "Назад", callback_data="back_to_staff")])
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text("Выберите услугу:", reply_markup=reply_markup)

# Обработка выбора услуги


async def choose_service(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    service_id = int(query.data.split("_")[1])
    context.user_data["service_id"] = service_id

    services_data = get_services()
    context.user_data["service_name"] = next(
        (s["title"] for s in services_data if s["id"] == service_id), "Неизвестная услуга")
    if context.user_data["service_name"] == "Неизвестная услуга":
        logger.warning(f"Не удалось найти услугу с ID {service_id}")

    staff_id = context.user_data.get("staff_id")
    available_dates = get_available_days(service_id, staff_id)
    if not available_dates:
        await query.edit_message_text("Не удалось получить доступные даты. Попробуйте позже.")
        return

    # Группируем даты по месяцам
    months = {}
    for date_str in available_dates:
        date_obj = datetime.strptime(date_str, "%Y-%m-%d").date()
        month_year = date_obj.strftime("%B %Y")  # Полное название месяца и год
        if month_year not in months:
            months[month_year] = []
        months[month_year].append(date_str)

    context.user_data["available_months"] = months

    keyboard = [
        [InlineKeyboardButton(translate_month_to_russian(
            month_year), callback_data=f"month_{month_year}")]
        for month_year in months.keys()
    ]
    keyboard.append([InlineKeyboardButton(
        "Назад", callback_data="back_to_services")])
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text("Выберите месяц:", reply_markup=reply_markup)

# Обработка выбора месяца


async def choose_month(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    selected_month_year = query.data.split("_")[1]
    context.user_data["selected_month_year"] = selected_month_year

    # Получаем даты для выбранного месяца
    available_dates = context.user_data["available_months"][selected_month_year]

    keyboard = []
    row = []
    for date_str in available_dates:
        date_obj = datetime.strptime(date_str, "%Y-%m-%d").date()
        day = date_obj.strftime("%d")  # Получаем только число
        weekday = get_weekday_russian(date_obj)  # Получаем день недели
        button_text = f"{day} ({weekday})"  # Формируем текст кнопки
        button = InlineKeyboardButton(
            button_text, callback_data=f"date_{date_str}")
        row.append(button)
        if len(row) == 3:  # Максимум 3 кнопки в строке
            keyboard.append(row)
            row = []
    if row:  # Добавляем последний неполный ряд
        keyboard.append(row)

    keyboard.append([InlineKeyboardButton(
        "Назад", callback_data="back_to_months")])  # Кнопка "Назад"
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text(f"Выберите дату в {translate_month_to_russian(selected_month_year)}:", reply_markup=reply_markup)


# Обработка выбора даты
async def choose_date(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    selected_date = query.data.split("_")[1]
    context.user_data["selected_date"] = selected_date

    staff_id = context.user_data.get("staff_id")
    service_id = context.user_data["service_id"]
    available_times = get_available_times(service_id, staff_id, selected_date)
    if not available_times:
        await query.edit_message_text("Не удалось получить доступное время. Попробуйте позже.")
        return

    keyboard = []
    row = []
    for i, time in enumerate(available_times):
        button = InlineKeyboardButton(
            time['time'], callback_data=f"time_{time['time']}")
        row.append(button)
        # 4 кнопки в строке или последний элемент
        if (i + 1) % 4 == 0 or i == len(available_times) - 1:
            keyboard.append(row)
            row = []

    keyboard.append([InlineKeyboardButton(
        "Назад", callback_data="back_to_dates")])
    reply_markup = InlineKeyboardMarkup(keyboard)

    context.user_data["choose_time_message_id"] = query.message.message_id

    await query.edit_message_text("Выберите время:", reply_markup=reply_markup)


# Обработка выбора времени
async def choose_time(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    selected_time = query.data.split("_")[1]
    context.user_data["selected_time"] = selected_time

    try:
        await context.bot.delete_message(
            chat_id=update.effective_chat.id,
            message_id=context.user_data["choose_time_message_id"]
        )
    except Exception as e:
        logger.warning(f"Не удалось удалить сообщение 'Выберите время:': {e}")

    user_id = str(update.effective_user.id)
    phone_data = load_phone_database()

    if user_id in phone_data and phone_data[user_id]:
        context.user_data["phone"] = phone_data[user_id]
        await confirm_booking(update, context)
    else:
        keyboard = [
            [KeyboardButton("Отправить номер телефона", request_contact=True)]]
        reply_markup = ReplyKeyboardMarkup(
            keyboard, one_time_keyboard=True, resize_keyboard=True)

        phone_request_message = await update.effective_chat.send_message(
            "Пожалуйста, отправьте ваш номер телефона, используя кнопку 'Отправить номер телефона'.",
            reply_markup=reply_markup
        )

        context.user_data["phone_request_message_id"] = phone_request_message.message_id


# Обработка ввода номера телефона
async def handle_phone(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if update.message.contact:
        phone = update.message.contact.phone_number
    else:
        reject_message = await update.message.reply_text("Пожалуйста, отправьте ваш номер телефона, используя кнопку 'Отправить номер телефона'.")
        context.user_data["reject_message_id"] = reject_message.message_id
        return

    if not phone:
        await update.message.reply_text("Не удалось получить номер телефона. Попробуйте еще раз.")
        return

    context.user_data["phone"] = phone

    user_id = str(update.effective_user.id)
    phone_data = load_phone_database()
    phone_data[user_id] = phone
    save_phone_database(phone_data)

    try:
        await context.bot.delete_message(
            chat_id=update.effective_chat.id,
            message_id=context.user_data["phone_request_message_id"]
        )
    except Exception as e:
        logger.warning(
            f"Не удалось удалить сообщение с запросом телефона: {e}")

    try:
        await context.bot.delete_message(
            chat_id=update.effective_chat.id,
            message_id=update.message.message_id
        )
    except Exception as e:
        logger.warning(
            f"Не удалось удалить сообщение пользователя с телефоном: {e}")

    if "reject_message_id" in context.user_data:
        try:
            await context.bot.delete_message(
                chat_id=update.effective_chat.id,
                message_id=context.user_data["reject_message_id"]
            )
        except Exception as e:
            logger.warning(
                f"Не удалось удалить сообщение об отклонении ручного ввода номера: {e}")
        del context.user_data["reject_message_id"]

    await confirm_booking(update, context)


# Подтверждение записи
async def confirm_booking(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    staff_id = context.user_data.get("staff_id")
    service_id = context.user_data["service_id"]
    selected_date = context.user_data["selected_date"]

    try:
        date_object = datetime.strptime(selected_date, "%Y-%m-%d")
        formatted_date = date_object.strftime("%d-%m-%Y")
    except ValueError:
        formatted_date = selected_date

    selected_time = context.user_data["selected_time"]
    phone = context.user_data["phone"]
    service_name = context.user_data["service_name"]

    if staff_id:
        staff_data = get_staff()
        if staff_data:
            staff_member = next(
                (s for s in staff_data if str(s["id"]) == staff_id), None)
            if staff_member:
                staff_name = staff_member["name"]
            else:
                staff_name = "Неизвестный сотрудник"
                logger.warning(f"Не удалось найти сотрудника с ID {staff_id}")
        else:
            staff_name = "Неизвестный сотрудник"
            logger.warning("Не удалось получить список сотрудников.")
    else:
        staff_name = "Любой сотрудник"

    message = (
        "<b>Проверьте данные:</b>\n"
        f"Сотрудник: {staff_name}\n"
        f"Услуга: {service_name}\n"
        f"Дата: {formatted_date}\n"
        f"Время: {selected_time}\n"
        f"Ваше имя: {update.effective_user.full_name}\n"
        f"Телефон: {phone}"
    )

    keyboard = [
        [InlineKeyboardButton("Изменить", callback_data="change_booking")],
        [InlineKeyboardButton(
            "Оформить запись", callback_data="confirm_booking_final")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.effective_chat.send_message(
        message,
        reply_markup=reply_markup,
        parse_mode=constants.ParseMode.HTML
    )

# Обработчик для кнопки "Изменить"


async def change_booking(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    keyboard = [
        [InlineKeyboardButton("Изменить Сотрудника",
                              callback_data="change_staff")],
        [InlineKeyboardButton(
            "Изменить Услугу", callback_data="change_service")],
        [InlineKeyboardButton("Изменить Дату", callback_data="change_date")],
        [InlineKeyboardButton("Изменить Время", callback_data="change_time")],
        [InlineKeyboardButton("Изменить Телефон",
                              callback_data="change_phone")],
        [InlineKeyboardButton("Отмена", callback_data="back_to_confirmation")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text("Что вы хотите изменить?", reply_markup=reply_markup)

# Обработчик кнопки "Отмена"


async def back_to_confirmation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    await confirm_booking(update, context)

# Обработчик для кнопки "Изменить телефон"


async def change_phone(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    keyboard = [
        [KeyboardButton("Отправить номер телефона", request_contact=True)]]
    reply_markup = ReplyKeyboardMarkup(
        keyboard, one_time_keyboard=True, resize_keyboard=True)

    phone_request_message = await update.effective_chat.send_message(
        "Пожалуйста, отправьте ваш новый номер телефона, используя кнопку 'Отправить номер телефона'.",
        reply_markup=reply_markup
    )

    context.user_data["phone_request_message_id"] = phone_request_message.message_id


# Обработчики для кнопок "Изменить..."
async def change_staff(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    staff_data = get_staff()
    if not staff_data:
        await query.edit_message_text("Не удалось получить список сотрудников. Попробуйте позже.")
        return

    keyboard = [
        [InlineKeyboardButton(staff_member["name"],
                              callback_data=f"staff_{staff_member['id']}")]
        for staff_member in staff_data
    ]
    keyboard.append([InlineKeyboardButton(
        "Любой сотрудник", callback_data="staff_any")])
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text("Выберите сотрудника:", reply_markup=reply_markup)


async def change_service(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    staff_id = context.user_data.get("staff_id")
    services_data = get_services(staff_id)
    if not services_data:
        await query.edit_message_text("Не удалось получить список услуг. Попробуйте позже.")
        return

    keyboard = [
        [InlineKeyboardButton(
            f"{service['title']} - {service.get('price_min', 'Неизвестно')} руб.", callback_data=f"service_{service['id']}")]
        for service in services_data
    ]
    keyboard.append([InlineKeyboardButton(
        "Назад", callback_data="back_to_staff")])
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text("Выберите услугу:", reply_markup=reply_markup)


async def change_date(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    service_id = context.user_data["service_id"]
    staff_id = context.user_data.get("staff_id")
    available_dates = get_available_days(service_id, staff_id)
    if not available_dates:
        await query.edit_message_text("Не удалось получить доступные даты. Попробуйте позже.")
        return

    # Группируем даты по месяцам
    months = {}
    for date_str in available_dates:
        date_obj = datetime.strptime(date_str, "%Y-%m-%d").date()
        month_year = date_obj.strftime("%B %Y")  # Полное название месяца и год
        if month_year not in months:
            months[month_year] = []
        months[month_year].append(date_str)

    context.user_data["available_months"] = months

    keyboard = [
        [InlineKeyboardButton(translate_month_to_russian(
            month_year), callback_data=f"month_{month_year}")]
        for month_year in months.keys()
    ]
    keyboard.append([InlineKeyboardButton(
        "Назад", callback_data="back_to_services")])
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text("Выберите месяц:", reply_markup=reply_markup)


async def change_time(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    selected_date = context.user_data["selected_date"]
    staff_id = context.user_data.get("staff_id")
    service_id = context.user_data["service_id"]
    available_times = get_available_times(service_id, staff_id, selected_date)
    if not available_times:
        await query.edit_message_text("Не удалось получить доступное время. Попробуйте позже.")
        return

    keyboard = []
    row = []
    for i, time in enumerate(available_times):
        button = InlineKeyboardButton(
            time['time'], callback_data=f"time_{time['time']}")
        row.append(button)
        if (i + 1) % 4 == 0:  # 4 кнопки в строке
            keyboard.append(row)
            row = []
    if row:  # Добавляем оставшиеся кнопки, если их меньше 4
        keyboard.append(row)

    keyboard.append([InlineKeyboardButton(
        "Назад", callback_data="back_to_dates")])
    reply_markup = InlineKeyboardMarkup(keyboard)

    context.user_data["choose_time_message_id"] = query.message.message_id

    await query.edit_message_text("Выберите время:", reply_markup=reply_markup)

# Обработчик для отклонения ручного ввода номера телефона


async def reject_manual_phone(update: Update, context: ContextTypes.DEFAULT_TYPE):
    reject_message = await update.message.reply_text("Пожалуйста, отправьте ваш номер телефона, используя кнопку 'Отправить номер телефона'.")
    context.user_data["reject_message_id"] = reject_message.message_id


async def confirm_booking_final(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await create_booking(update, context)


async def back_to_staff(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    staff_data = get_staff()
    if not staff_data:
        await query.edit_message_text("Не удалось получить список сотрудников. Попробуйте позже.")
        return

    keyboard = [
        [InlineKeyboardButton(staff_member["name"],
                              callback_data=f"staff_{staff_member['id']}")]
        for staff_member in staff_data
    ]
    keyboard.append([InlineKeyboardButton(
        "Любой сотрудник", callback_data="staff_any")])
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text("Выберите сотрудника:", reply_markup=reply_markup)


async def back_to_services(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    staff_id = context.user_data.get("staff_id")
    services_data = get_services(staff_id)
    if not services_data:
        await query.edit_message_text("Не удалось получить список услуг. Попробуйте позже.")
        return

    keyboard = [
        [InlineKeyboardButton(
            f"{service['title']} - {service.get('price_min', 'Неизвестно')} руб.", callback_data=f"service_{service['id']}")]
        for service in services_data
    ]
    keyboard.append([InlineKeyboardButton(
        "Назад", callback_data="back_to_staff")])
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text("Выберите услугу:", reply_markup=reply_markup)


async def back_to_dates(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    # Возвращаемся к выбору месяца
    await change_date(update, context)


async def back_to_months(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    service_id = context.user_data["service_id"]
    staff_id = context.user_data.get("staff_id")
    available_dates = get_available_days(service_id, staff_id)
    if not available_dates:
        await query.edit_message_text("Не удалось получить доступные даты. Попробуйте позже.")
        return

    # Группируем даты по месяцам
    months = {}
    for date_str in available_dates:
        date_obj = datetime.strptime(date_str, "%Y-%m-%d").date()
        month_year = date_obj.strftime("%B %Y")  # Полное название месяца и год
        if month_year not in months:
            months[month_year] = []
        months[month_year].append(date_str)

    context.user_data["available_months"] = months

    keyboard = [
        [InlineKeyboardButton(translate_month_to_russian(
            month_year), callback_data=f"month_{month_year}")]
        for month_year in months.keys()
    ]
    keyboard.append([InlineKeyboardButton(
        "Назад", callback_data="back_to_services")])
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text("Выберите месяц:", reply_markup=reply_markup)


# Обработка подтверждения записи
async def create_booking(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    staff_id = context.user_data.get("staff_id")
    service_id = context.user_data["service_id"]
    selected_date = context.user_data["selected_date"]

    try:
        date_object = datetime.strptime(selected_date, "%Y-%m-%d")
        formatted_date = date_object.strftime("%d-%m-%Y")
    except ValueError:
        formatted_date = selected_date

    selected_time = context.user_data["selected_time"]
    phone = context.user_data["phone"]
    email = "user@example.com"  # TODO: Запросить email у пользователя
    service_name = context.user_data["service_name"]

    try:
        date_time_str = f"{selected_date} {selected_time}"
        date_time_obj = datetime.strptime(
            date_time_str, "%Y-%m-%d %H:%M")
        formatted_date_time = date_time_obj.strftime(
            "%Y-%m-%d %H:%M:%S")
    except ValueError as e:
        logger.error(f"Ошибка при форматировании даты и времени: {e}")
        await query.edit_message_text("Некорректный формат даты или времени. Попробуйте еще раз.")
        return

    booking_data = {
        "booking_id": 0,
        "fullname": update.effective_user.full_name,
        "phone": phone,
        "email": email,
        "service_id": service_id,
        "date_time": formatted_date_time,
        "staff_id": staff_id,
        "comment": "Запись через Telegram-бота",
    }

    try:
        booked = api.book(**booking_data)
        logger.debug(f"API Response: {booked}")
        logger.info(f"BOOKED: {booked}")

        if isinstance(booked, tuple) and booked[0] is True:
            staff_id_for_name = context.user_data.get("staff_id")
            if staff_id_for_name:
                staff_data = get_staff()
                if staff_data:
                    staff_member = next((s for s in staff_data if str(
                        s["id"]) == staff_id_for_name), None)
                    staff_name = staff_member["name"] if staff_member else "Неизвестный сотрудник"
                else:
                    staff_name = "Неизвестный сотрудник"
            else:
                staff_name = "Любой сотрудник"

            confirmation_message = (
                "<b>Запись подтверждена!</b>\n"
                f"Дата: {formatted_date}\n"
                f"Время: {selected_time}\n"
                f"Услуга: {service_name}\n"
                f"Сотрудник: {staff_name}"
            )
            await query.edit_message_text(confirmation_message, parse_mode=constants.ParseMode.HTML)

            context.user_data.clear()
        else:
            error_message = "Неизвестная ошибка при создании записи."
            if isinstance(booked, tuple) and len(booked) > 1:
                error_message = booked[1]

            await query.edit_message_text(f"Произошла ошибка при создании записи: {error_message}")

    except Exception as e:
        logger.error(f"Ошибка при создании записи: {e}")
        await query.edit_message_text("Произошла ошибка при создании записи. Попробуйте позже.")

# Запуск бота


def main():
    application = ApplicationBuilder().token(TELEGRAM_BOT_TOKEN).build()

    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("book", book))

    application.add_handler(CallbackQueryHandler(
        choose_staff, pattern="^staff_"))
    application.add_handler(CallbackQueryHandler(
        choose_service, pattern="^service_"))
    application.add_handler(CallbackQueryHandler(
        choose_month, pattern="^month_"))
    application.add_handler(CallbackQueryHandler(
        choose_date, pattern="^date_"))
    application.add_handler(CallbackQueryHandler(
        choose_time, pattern="^time_"))
    application.add_handler(CallbackQueryHandler(
        confirm_booking_final, pattern="^confirm_booking_final"))
    application.add_handler(CallbackQueryHandler(
        back_to_staff, pattern="^back_to_staff"))
    application.add_handler(CallbackQueryHandler(
        back_to_services, pattern="^back_to_services"))
    application.add_handler(CallbackQueryHandler(
        back_to_dates, pattern="^back_to_dates"))
    application.add_handler(CallbackQueryHandler(
        back_to_months, pattern="^back_to_months"))
    application.add_handler(CallbackQueryHandler(
        change_booking, pattern="^change_booking"))
    application.add_handler(CallbackQueryHandler(
        change_staff, pattern="^change_staff"))
    application.add_handler(CallbackQueryHandler(
        change_service, pattern="^change_service"))
    application.add_handler(CallbackQueryHandler(
        change_date, pattern="^change_date"))
    application.add_handler(CallbackQueryHandler(
        change_time, pattern="^change_time"))
    application.add_handler(CallbackQueryHandler(
        change_phone, pattern="^change_phone"))
    application.add_handler(CallbackQueryHandler(
        back_to_confirmation, pattern="^back_to_confirmation"))

    application.add_handler(MessageHandler(filters.CONTACT, handle_phone))
    application.add_handler(MessageHandler(
        filters.TEXT & ~filters.COMMAND & ~filters.CONTACT, reject_manual_phone))

    application.run_polling()


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        logger.info("Бот остановлен вручную (Ctrl+C).")
    except Exception as e:
        logger.error(f"Ошибка: {e}")


================================================
File: config.py
================================================
# config.py
import os
from dotenv import load_dotenv

load_dotenv()

basedir = os.path.abspath(os.path.dirname(__file__))


class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'you-will-never-guess'
    PARTNER_TOKEN = os.environ.get('PARTNER_TOKEN')
    API_KEY = os.environ.get('YCLIENTS_API_KEY')
    # ID вашего приложения в YCLIENTS
    APPLICATION_ID = os.environ.get('APPLICATION_ID')
    WEBHOOK_URL = os.environ.get('WEBHOOK_URL')  # URL для вебхуков
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or \
        'sqlite:///' + os.path.join(basedir, 'app.db')
    SQLALCHEMY_TRACK_MODIFICATIONS = False


================================================
File: phone_database.json
================================================
{
    "814018098": "79787123374",
    "8194195320": "+79790274479"
}

================================================
File: start_app.sh
================================================
    #!/bin/bash
    set -x
    source /home/belpav/ycbot/venv/bin/activate
    echo "Virtualenv activated"
    exec /home/belpav/ycbot/venv/bin/gunicorn --workers 3 --bind 0.0.0.0:8000 app:app
    echo "Gunicorn started" 
    

================================================
File: utils.py
================================================
# utils.py
import base64
import hashlib
import hmac
import json


def decode_user_data(user_data_encoded, partner_token):
    """Декодирует user_data из base64 и проверяет подпись."""
    try:
        user_data_bytes = base64.b64decode(user_data_encoded)
        user_data_str = user_data_bytes.decode('utf-8')
        return json.loads(user_data_str)
    except (base64.binascii.Error, UnicodeDecodeError, json.JSONDecodeError) as e:
        print(f"Ошибка декодирования user_data: {e}")
        return None


def verify_signature(user_data_encoded, user_data_sign, partner_token):
    """Проверяет подпись user_data."""
    try:
        user_data_bytes = base64.b64decode(user_data_encoded)
        user_data_str = user_data_bytes.decode('utf-8')
        expected_signature = hmac.new(
            partner_token.encode('utf-8'),
            user_data_str.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()
        return hmac.compare_digest(user_data_sign, expected_signature)
    except (base64.binascii.Error, UnicodeDecodeError) as e:
        print(f"Ошибка проверки подписи: {e}")
        return False


================================================
File: yc.py
================================================
# yclients.py
import requests
import json


def activate_integration(salon_id, api_key):
    """Активирует интеграцию для указанного salon_id и возвращает USER_ID."""
    url = f"https://api.yclients.com/api/v1/company/{salon_id}/integrations"  # Пример URL, уточните в документации YClients
    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json",
    }
    #  В теле запроса больше не нужен user_id
    data = {}
    try:
        response = requests.post(url, headers=headers, data=json.dumps(data))
        response.raise_for_status()
        response_json = response.json()
        if response_json.get("success"):
            # Получаем USER_ID из ответа
            user_id = response_json["data"]["user_id"]
            return True, user_id, response_json  # Возвращаем True, USER_ID и полный ответ
        else:
            return False, None, response_json  # Возвращаем False, None и полный ответ
    except requests.exceptions.RequestException as e:
        return False, None, str(e)


def send_integration_settings(salon_id, application_id, api_key, webhook_urls, channels=None):
    """Отправляет настройки интеграции в YCLIENTS."""
    url = "https://api.yclients.com/marketplace/partner/callback"
    headers = {
        "Content-Type": "application/json"
    }
    data = {
        "salon_id": salon_id,
        "application_id": application_id,
        "api_key": api_key,
        "webhook_urls": webhook_urls
    }
    if channels:
        data["channels"] = channels

    try:
        response = requests.post(url, headers=headers, data=json.dumps(data))
        response.raise_for_status()
        return True, response.json()
    except requests.exceptions.RequestException as e:
        return False, str(e)


================================================
File: daemon, ngnix/default
================================================
##
# You should look at the following URL's in order to grasp a solid understanding
# of Nginx configuration files in order to fully unleash the power of Nginx.
# https://www.nginx.com/resources/wiki/start/
# https://www.nginx.com/resources/wiki/start/topics/tutorials/config_pitfalls/
# https://wiki.debian.org/Nginx/DirectoryStructure
#
# In most cases, administrators will remove this file from sites-enabled/ and
# leave it as reference inside of sites-available where it will continue to be
# updated by the nginx packaging team.
#
# This file will automatically load configuration files provided by other
# applications, such as Drupal or Wordpress. These applications will be made
# available underneath a path with that package name, such as /drupal8.
#
# Please see /usr/share/doc/nginx-doc/examples/ for more detailed examples.
##

# Default server configuration
#
server {
	listen 80 default_server;
	listen [::]:80 default_server;

	# SSL configuration
	#
	# listen 443 ssl default_server;
	# listen [::]:443 ssl default_server;
	#
	# Note: You should disable gzip for SSL traffic.
	# See: https://bugs.debian.org/773332
	#
	# Read up on ssl_ciphers to ensure a secure configuration.
	# See: https://bugs.debian.org/765782
	#
	# Self signed certs generated by the ssl-cert package
	# Don't use them in a production server!
	#
	# include snippets/snakeoil.conf;

	root /var/www/html;

	# Add index.php to the list if you are using PHP
	index index.html index.htm index.nginx-debian.html;

	server_name _;

	location / {
		# First attempt to serve request as file, then
		# as directory, then fall back to displaying a 404.
		try_files $uri $uri/ =404;
	}

	# pass PHP scripts to FastCGI server
	#
	#location ~ \.php$ {
	#	include snippets/fastcgi-php.conf;
	#
	#	# With php-fpm (or other unix sockets):
	#	fastcgi_pass unix:/var/run/php/php7.4-fpm.sock;
	#	# With php-cgi (or other tcp sockets):
	#	fastcgi_pass 127.0.0.1:9000;
	#}

	# deny access to .htaccess files, if Apache's document root
	# concurs with nginx's one
	#
	#location ~ /\.ht {
	#	deny all;
	#}
}


# Virtual Host configuration for example.com
#
# You can move that to a different file under sites-available/ and symlink that
# to sites-enabled/ to enable it.
#
#server {
#	listen 80;
#	listen [::]:80;
#
#	server_name example.com;
#
#	root /var/www/example.com;
#	index index.html;
#
#	location / {
#		try_files $uri $uri/ =404;
#	}
#}


================================================
File: daemon, ngnix/myapp.service
================================================
[Unit]
Description=YcBOT
After=network.target

[Service]
User=belpav
WorkingDirectory=/home/belpav/ycbot
Environment="PATH=/home/belpav/ycbot/venv/bin"
ExecStart=/home/belpav/ycbot/venv/bin/gunicorn --workers 3 --bind 0.0.0.0:8000 app:app
Restart=on-failure

[Install]
WantedBy=multi-user.target

================================================
File: daemon, ngnix/ycbot
================================================
server {
    listen 80;
    server_name ycbot.ru www.ycbot.ru;

    location / {
        proxy_pass http://127.0.0.1:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    location /static {
        alias /home/belpav/ycbot/static;
    }
}

================================================
File: tamplates/login.html
================================================
<!DOCTYPE html>
<html>

<head>
	<title>Вход</title>
</head>

<body>
	<h1>Вход</h1>
	{% if error %}
	<p style="color: red;">{{ error }}</p>
	{% endif %}
	<form method="POST" action="/login">
		<label for="email">Email:</label><br>
		<input type="email" id="email" name="email"><br><br>

		<label for="password">Пароль:</label><br>
		<input type="password" id="password" name="password"><br><br>

		<input type="submit" value="Войти">
	</form>
</body>

</html>

================================================
File: tamplates/profile.html
================================================
<!DOCTYPE html>
<html>

<head>
	<title>Профиль</title>
</head>

<body>
	<h1>Профиль</h1>
	<p>Привет, {{ user.name }}!</p>
	<p>Email: {{ user.email }}</p>
	<a href="/logout">Выйти</a>
</body>

</html>

================================================
File: tamplates/signup.html
================================================
<!DOCTYPE html>
<html>

<head>
	<title>Регистрация</title>
</head>

<body>
	<h1>Регистрация</h1>
	<form method="POST" action="/activate">
		<input type="hidden" name="salon_id" value="{{ salon_id }}">
		{% if salon_ids %}
		{% for salon_id_item in salon_ids %}
		<input type="hidden" name="salon_ids[]" value="{{ salon_id_item }}">
		{% endfor %}
		{% endif %}

		<input type="hidden" name="user_id" value="{{ user_id }}">

		{% if user_data %}
		<label for="name">Имя:</label><br>
		<input type="text" id="name" name="name" value="{{ user_data.get('name', '') }}"><br><br>

		<label for="email">Email:</label><br>
		<input type="email" id="email" name="email" value="{{ user_data.get('email', '') }}" readonly><br><br>

		<label for="phone">Телефон:</label><br>
		<input type="tel" id="phone" name="phone" value="{{ user_data.get('phone', '') }}"><br><br>
		{% else %}
		<label for="name">Имя:</label><br>
		<input type="text" id="name" name="name"><br><br>

		<label for="email">Email:</label><br>
		<input type="email" id="email" name="email"><br><br>

		<label for="phone">Телефон:</label><br>
		<input type="tel" id="phone" name="phone"><br><br>
		{% endif %}

		<label for="password">Пароль:</label><br>
		<input type="password" id="password" name="password"><br><br>

		<input type="submit" value="Зарегистрироваться">
	</form>
</body>

</html>

